import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { dbConnectionManager } from '@/lib/db-connection-manager';

// Cache ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
const articleCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 60 * 1000; // Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const cacheKey = searchParams.toString();
  
  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒØ§Ø´ Ø£ÙˆÙ„Ø§Ù‹
  const cached = articleCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    console.log('âœ… Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª Ù…Ù† Ø§Ù„ÙƒØ§Ø´');
    return NextResponse.json(cached.data, {
      headers: {
        'X-Cache': 'HIT',
        'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300',
      }
    });
  }

  try {
    const page = parseInt(searchParams.get('page') || '1');
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 200);
    const status = searchParams.get('status') || 'published';
    const category_id = searchParams.get('category_id');
    const search = searchParams.get('search');
    const sort = searchParams.get('sort') || 'published_at';
    const order = searchParams.get('order') || 'desc';
    const skip = (page - 1) * limit;

    console.log(`ğŸ” ÙÙ„ØªØ±Ø© Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª Ø­Ø³Ø¨ category: ${category_id}`);

    // Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙˆØ· Ø§Ù„Ø¨Ø­Ø«
    const where: any = {};
    
    if (status !== 'all') {
      where.status = status;
    }
    
    if (category_id && category_id !== 'all') {
      where.category_id = category_id;
    }
    
    if (search) {
      where.OR = [
        { title: { contains: search } },
        { excerpt: { contains: search } }
      ];
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ØªØ±ØªÙŠØ¨ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
    const orderBy: any = {};
    orderBy[sort] = order;

    // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª Ù…Ø¹ Ø§Ù„Ø¹Ø¯ Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠ
    const [articles, totalCount] = await Promise.all([
      dbConnectionManager.executeWithConnection(async () => {
        return await prisma.articles.findMany({
          where,
          skip,
          take: limit,
          orderBy,
          include: {
            categories: {
              select: {
                id: true,
                name: true,
                slug: true
              }
            },
            author: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        });
      }),
      
      dbConnectionManager.executeWithConnection(async () => {
        return await prisma.articles.count({ where });
      })
    ]);

    // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
    const enrichedArticles = articles.map(article => ({
      ...article,
      image: article.featured_image,
      category: article.categories,
      author_name: article.author?.name || null,
      comments_count: 0 // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¹Ø¯ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ù„Ø§Ø­Ù‚Ø§Ù‹
    }));

    const response = {
      success: true,
      articles: enrichedArticles,
      total: totalCount,
      page,
      limit,
      totalPages: Math.ceil(totalCount / limit),
      hasMore: skip + limit < totalCount
    };

    // Ø­ÙØ¸ ÙÙŠ Ø§Ù„ÙƒØ§Ø´
    articleCache.set(cacheKey, { data: response, timestamp: Date.now() });
    
    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø´ Ø§Ù„Ù‚Ø¯ÙŠÙ…
    if (articleCache.size > 100) {
      const oldestKey = Array.from(articleCache.keys())[0];
      articleCache.delete(oldestKey);
    }

    return NextResponse.json(response, {
      headers: {
        'X-Cache': 'MISS',
        'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300',
      }
    });

  } catch (error: any) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù‚Ø§Ù„Ø§Øª',
      details: error.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'
    }, { status: 500 });
  }
}

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø§Ù„ Ø¬Ø¯ÙŠØ¯
export async function POST(request: NextRequest) {
  try {
    const data = await request.json()
    
    const article = await dbConnectionManager.executeWithConnection(async () => {
      return await prisma.articles.create({
        data: {
          ...data,
          id: data.id || generateId(),
          created_at: new Date(),
          updated_at: new Date()
        }
      })
    })
    
    return NextResponse.json({
      success: true,
      article
    }, { status: 201 })
    
  } catch (error: any) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ù„:', error)
    
    return NextResponse.json({
      success: false,
      error: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ù„',
      details: error.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'
    }, { status: 500 })
  }
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙˆÙ„ÙŠØ¯ ID
function generateId() {
  return `article_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}
